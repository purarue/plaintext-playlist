#!/bin/bash
# plainplay, an script to maintain plaintext playlists
# run plainplay -h for help
# see https://gitlab.com/seanbreckenridge/plaintext-playlist
#
# For reference, variable styling is:
# ENVIRONMENT_VARIABLES
# GlobalVariables
# temporaryVariables

# Global Variables
ConfDir=
MusicDir=
# defaults to fzf interactive if not set
ReadInputType=MULTI_SELECT_FZF
ResolveAutoConfirm=
Action=
ActivePlaylist=
# used for shuffleall/playall
AllActivePlaylists=()

readonly PromptHistoryFile="${PLAINTEXT_PLAYLIST_HISTORY:-${XDG_CACHE_HOME:-$HOME/.cache}}/plaintext_playlist_history.txt"

# set default fzf command
export FZF_DEFAULT_COMMAND="find -type f | sort"

# error helper
abort() {
	echo "$1" 1>&2
	exit 1
}

# require that a executable be installed
require() {
	[[ $(command -v "$1") ]] || abort "This part of the application requires ${1}, but I can't seem to find it on your \$PATH"
}
require realpath
require printf
require sed

# HELP RELATED

# A list of commands
commands_list() {
	cat <<EOF
add <playlist>                | Adds one or more songs to a playlist
remove <playlist>             | Removes one of more songs from a playlist
play <playlist>               | Play songs from a playlist
playall <playlist>...         | Play songs from multiple playlists
shuffle <playlist>            | Shuffle songs from a playlist
shuffleall <playlist>...      | Shuffle songs from multiple playlists
list <playlist>               | List songs in a playlist
unique <playlist>             | Removes duplicates from a playlist
exif <playlist>               | Displays exif data for items in a playlist
playlist-create <playlist>    | Creates a new playlist - a playlist file
playlist-remove <playlist>    | Removes an existing playlist - deletes a playlist file
playlist-list                 | List the full paths of each of your playlist files
playlistdir                   | Print the location of the playlist directory
check                         | Makes sure that all songs in all your playlists exist
resolve                       | Attempts to fix broken paths in playlists
EOF
}

# print help for user
print_help() {
	cat <<EOF
Usage: plaintext [-h] [-] [COMMAND [ARGS]]

  Interactive terminal playlist manager, storing contents in readable text files
  run without a COMMAND to drop into interactive mode

  add and remove defaults to presenting you an
  fzf interface to add/remove items.

  A hyphen (-) can be passed with add
  to instead recieve filenames from stdin
  expects filenames to be in the correct format
  (cd to your Music dir and use find for good results)
  
  --auto-confirm can be passed with 'resolve' to automatically
  use the closest match instead of prompting you to choose
  one of the closest matching files to fix broken filepaths

  e.g.: find somedirectory -name "*.flac" | plainplay - add rock

  <playlist> specifies either the
  name (without the location/.txt extension)
  or the location of one of the playlists

EOF
	commands_list
	exit 0
}

# prints help and exits if the user asked for help
check_for_help() {
	if [[ $1 =~ "help" || $1 == "-h" ]]; then
		print_help
		exit 0
	fi
}

# APPLICATION SETUP

# resolve configuration location, setup playlist dir
application_setup() {
	# PLAINTEXT_PLAYLIST_PLAYLISTS can be set by the user to override,
	# else respect XDG, else put config in ~/.local/share/plaintext_playlist
	ConfDir="${PLAINTEXT_PLAYLIST_PLAYLISTS:=${XDG_DATA_HOME:-$HOME/.local/share}/plaintext_playlist}"
	# error if user hasn't set music dir
	MusicDir="${PLAINTEXT_PLAYLIST_MUSIC_DIR?:'ERROR PLAINTEXT_PLAYLIST_MUSIC_DIR (your root music folder) is not set as an environment variable. e.g.: PLAINTEXT_PLAYLIST_MUSIC_DIR=~/Music plainplay.'}"
	[[ -d "$MusicDir" ]] || abort "Error: ${PLAINTEXT_PLAYLIST_MUSIC_DIR} doesn't exist.\nThat should be the main, top-level folder where you keep your music locally."
	# create playlist dir if it doesnt exist.
	if [[ ! -d "$ConfDir" ]]; then
		printf "Creating playlist directory at '%s'\n" "$ConfDir"
		mkdir -p "$ConfDir" || exit 1
	fi
}

# ARGUMENT PARSING/PROMPTING

# parse arguments from command line.
parse_args() {
	while [[ -n "$1" ]]; do
		case "$1" in
		add)
			Action=ADD
			ActivePlaylist="$2"
			shift
			;;
		remove)
			Action=REMOVE
			ActivePlaylist="$2"
			shift
			;;
		list)
			Action=LIST
			ActivePlaylist="$2"
			shift
			break
			;;
		play)
			Action=PLAY
			ActivePlaylist="$2"
			shift
			break
			;;

		playall)
			Action=PLAYALL
			ActivePlaylist="$2"
			AllActivePlaylists+=("$2")
			shift
			;;

		shuffle)
			Action=SHUFFLE
			ActivePlaylist="$2"
			shift
			break
			;;

		shuffleall)
			Action=SHUFFLEALL
			ActivePlaylist="$2"
			AllActivePlaylists+=("$2")
			shift
			;;

		unique)
			Action=UNIQUE
			ActivePlaylist="$2"
			shift
			break
			;;

		exif)
			Action=EXIF
			ActivePlaylist="$2"
			shift
			break
			;;

		playlist-create)
			Action=PLAYLIST_CREATE
			ActivePlaylist="$2"
			shift
			break
			;;

		playlist-remove)
			Action=PLAYLIST_REMOVE
			ActivePlaylist="$2"
			shift
			break
			;;

		playlist-list)
			Action=PLAYLIST_LIST
			break
			;;

		playlistdir)
			Action=PLAYLISTDIR
			break
			;;

		check)
			Action=CHECK
			break
			;;
		resolve)
			Action=RESOLVE
			;;
		-)
			ReadInputType=FROM_STDIN
			;;
		--auto-confirm)
			ResolveAutoConfirm="--auto-confirm"
			;;

		*)
			case "$Action" in
			# if this is SHUFFLEALL or PLAYALL, save extra arguments
			*ALL)
				AllActivePlaylists+=("$1")
				;;
			*)
				printf "Error: Unexpected argument: %s\n\n" "$1" 1>&2
				print_help
				exit 1
				;;
			esac
			;;
		esac
		shift # remove current item from args
	done
	# if nothing was passed by the user
	[[ -z "$Action" ]] && pick_command_interactive
}

# prompts the user with the list of commands, and lets them select one of them
pick_command_interactive() {
	require fzf
	rawFzfChoice="$(commands_list | fzf -i --prompt='Run > ' --history="$PromptHistoryFile")" || abort "Error: You didn't provide a valid command."
	# get the first argument (e.g. add|remove|playlist-list)
	firstArg=("${rawFzfChoice%% *| *}")
	parse_args "${firstArg[@]}"
}

# returns the playlist path for a path/name if it exists.
# If -x is provided as the second argument, exits if playlist path doesn't exist
get_playlist_path() {
	fullPath="$(realpath "$1")"
	# if the full path exists
	if [[ -e "$fullPath" ]]; then
		echo -e "$fullPath"
	# else if the file is just a name (e.g. rock{,.txt} for $ConfDir/rock.txt)
	else
		fullPath="${ConfDir}/${1%.txt}.txt"
		if [[ -f "$fullPath" ]]; then
			echo -e "$fullPath"
		else
			# if not told to exit, prints the path, even though the path may not exist
			if [[ "$2" = "-x" ]]; then
				abort "Error: Could not find a matching playlist for: ${1}"
			else
				echo -e "$fullPath"
			fi
		fi
	fi
}

make_sure_playlists_exist() {
	(($(playlist_count) == 0)) && abort "Error: No playlists exist. Create one before trying to select one"
}

# presents the user with a prompt of playlists to choose from
pick_existing_playlist() {
	require fzf
	make_sure_playlists_exist
	playlistName="$(list_playlists | fzf -i --prompt='Select a playlist > ' --preview="cat \"${ConfDir}/\"{}.txt")" || abort "Error: You didn't select a valid playlist."
	echo -e "$playlistName"
}

# sets AllActivePlaylists to whatever the user selects
pick_mutliple_existing_playlists() {
	require fzf
	make_sure_playlists_exist
	playlistNames="$(list_playlists | fzf -m -i --prompt="Select multiple playlists by using 'Tab' > " --preview="cat \"${ConfDir}/\"{}.txt")" || abort "Error: You didn't select a valid playlist."
	readarray -t <<<"$playlistNames"
	AllActivePlaylists=("${MAPFILE[@]}")
}

# lists the names of the playlists (without .txt)
list_playlists() {
	command ls -1 "$ConfDir" | grep -i ".txt$" | sed -e "s/\.txt//g"
}

# returns the number of playlists
playlist_count() {
	command ls -1 "$ConfDir" | wc -l
}

# ask the user for some input, hit enter to continue. "$1" is the prompt string
generic_input() {
	read -e -p "$1" -r "reply"
	echo -e "$reply"
}

# uses the current directory plus passed filenames to resolve relative paths
# into the correct format for a playlist file. accepts relative filenames from stdin
convert_to_playlist_filenames() {
	require sed
	relativeFilenames="$(cat)"
	# get absolute path of all of the music to be added
	absoluteFilenames="$(sed -e "s#^.##" -e "s#^#$PWD#" <<<"$relativeFilenames")"
	# make sure user gave data
	[[ -z "$absoluteFilenames" ]] && abort "Did not recieve any filenames to add"
	# if the $MusicDir is a link, (e.g. linked to some other drive)
	# also replace that path
	absoluteNoLinkFilename="$(realpath "$MusicDir")"
	# convert to relative filenames:
	echo -e "$absoluteFilenames" | sed -e "s|^${MusicDir%/}/||" -e "s|^${absoluteNoLinkFilename%/}/||"
}

# checks a playlist file for broken paths
check_playlist() {
	playlistToCheck="$1"
	printf "Checking '%s'...\n" "$playlistToCheck"
	while read -r song; do
		songFullPath="${MusicDir%/}/${song}"
		[[ -e "$songFullPath" ]] || printf "Error: '%s' doesn't exist\n" "$songFullPath" 1>&2
	done <"$playlistToCheck"
}

# safely concatenates the files in AllActivePlaylists, prints the result to STDOUT
# incase files dont end properly with a newline, this adds an extra line
# to the end, and then removes it if it was empty
safe_concat() {
	{
		for pfile in "${AllActivePlaylists[@]}"; do
			cat "$pfile"
			echo
		done
	} | sed -e "/^\s*$/d"
}

# "main"
run_plaintext_playlist() {
	# Validate Playlist based on given arguments
	# Prompt user if necessary
	case "$Action" in
	ADD | REMOVE | LIST | UNIQUE | EXIF | PLAY | SHUFFLE | PLAYLIST_REMOVE)
		if [[ -z "$ActivePlaylist" ]]; then
			ActivePlaylist="$(pick_existing_playlist)" || exit 1
		fi
		ActivePlaylist="$(get_playlist_path "$ActivePlaylist" -x)" || exit 1
		;;
	PLAYALL | SHUFFLEALL)
		# if no playlist at all was selected
		if [[ -z "$ActivePlaylist" ]]; then
			pick_mutliple_existing_playlists || exit 1
		fi
		# convert each item in the array to a path
		tempResult=()
		for plist in "${AllActivePlaylists[@]}"; do
			tempResult+=("$(get_playlist_path "$plist" -x)") || exit 1
		done
		AllActivePlaylists=("${tempResult[@]}")
		;;

	PLAYLIST_CREATE)
		if [[ -z "$ActivePlaylist" ]]; then
			ActivePlaylist="$(get_playlist_path "$(generic_input 'Name of new playlist: ')")" || exit 1
		fi
		;;
	esac

	# printf "%s\n" "$Action"
	# printf "%s\n" "$ActivePlaylist"
	# printf "%s\n" "$ReadInputType"
	# Run, based on Action
	case "$Action" in
	PLAYLIST_CREATE)
		if [[ -f "$ActivePlaylist" ]]; then
			printf "Warning: Playlist '%s' already exists.\n" "$ActivePlaylist" 1>&2
		else
			touch "$ActivePlaylist"
			printf "Created Playlist: '%s'\n" "$ActivePlaylist"
		fi
		;;
	PLAYLIST_LIST)
		find "$ConfDir" -type f -iname "*.txt"
		;;

	PLAYLIST_REMOVE)
		printf "Are you sure you want to delete '%s'? [y/N] " "$ActivePlaylist"
		read -r "response"
		if [[ $response =~ ^[Yy] ]]; then
			rm "$ActivePlaylist"
			printf "Deleted Playlist: '%s'\n" "$ActivePlaylist"
		fi
		;;
	PLAYLISTDIR)
		echo "${ConfDir}"
		;;
	CHECK)
		while IFS= read -r -d '' playlistToCheck; do
			check_playlist "$playlistToCheck"
		done < <(find "${ConfDir}" -type f -iname "*.txt" -print0)
		;;
	RESOLVE)
		require resolve_cmd_plainplay
		require python3
		resolve_cmd_plainplay "$ConfDir" "$MusicDir" "$ResolveAutoConfirm"
		;;
	ADD)
		case "$ReadInputType" in
		FROM_STDIN)
			filenamesToAdd="$(cat)"
			echo -e "$filenamesToAdd" >>"$ActivePlaylist"
			;;

		MULTI_SELECT_FZF)
			require fzf
			songsToAdd="$(fzf -m -i --prompt="Select songs to add. Hit 'Tab' to select multiple > ")" || abort "Error: You didn't provide any songs to add..."
			fixedFilenames="$(convert_to_playlist_filenames <<<"$songsToAdd")"
			echo -e "Adding the following to ${ActivePlaylist}:"
			echo -e "$fixedFilenames"
			echo -e "$fixedFilenames" >>"$ActivePlaylist"
			;;
		*)
			abort "Unrecognized selection type. Expected FROM_STDIN or MULTI_SELECT_FZF"
			;;

		esac
		;;
	REMOVE)
		require fzf
		linesToRemove="$(fzf -m -i --prompt="Select songs to add. Hit 'Tab' to select multiple > " <"$ActivePlaylist")" || abort "Error: you didn't provide any songs to remove..."
		filteredSongs="$(grep -Fxv "$linesToRemove" <"$ActivePlaylist")"
		echo -e "$filteredSongs" >"$ActivePlaylist"
		echo -e "Removed the following from ${ActivePlaylist}:"
		echo -e "$linesToRemove"
		;;
	LIST)
		cat "$ActivePlaylist"
		;;
	UNIQUE)
		require uniq
		filteredPlaylistFile='/tmp/filtered_playlist'
		uniq "$ActivePlaylist" >"$filteredPlaylistFile"
		mv "$filteredPlaylistFile" "$ActivePlaylist"
		printf "Ran 'uniq' on %s\n" "$ActivePlaylist"
		;;
	EXIF)
		require exiftool
		filepath="$(cd "$MusicDir" && fzf +m -i --prompt="Print exiftool for > " --preview="cd \"$MusicDir\" && exiftool {}" <"$ActivePlaylist")" || abort "No filepath selected to print exif data for."
		cd "$MusicDir" && exiftool "$filepath"
		;;
	PLAY)
		require mpv
		cd "$MusicDir" && mpv --playlist=- --no-audio-display <"$ActivePlaylist"
		;;

	PLAYALL)
		require mpv
		cd "$MusicDir" && safe_concat | mpv --playlist=- --no-audio-display
		;;

	SHUFFLE)
		require mpv
		cd "$MusicDir" && mpv --shuffle --playlist=- --no-audio-display <"$ActivePlaylist"
		;;

	SHUFFLEALL)
		require mpv
		cd "$MusicDir" && safe_concat | mpv --playlist=- --shuffle --no-audio-display
		;;

	*)
		abort "Unexpected Error. Could not find action ${Action}"
		;;

	esac
}

check_for_help "$@"
application_setup
parse_args "$@"
run_plaintext_playlist "$Action" "$ActivePlaylist" || exit 1
